МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ

Кафедра «Програмної інженерії»



ЗВІТ
З практичної роботи №2
з дисципліни «Архітектура програмного забезпечення»



Виконав:
ст. гр. ПЗПІ-22-8
Кривошапко С. С.	Перевірив:
 ст. викладач кафедри ПІ
Сокорчук І.П.
	



Харків 2025
1 ІСТОРІЯ ЗМІН

Розділ призначений для відображення історії внесення змін, що наведено на таблиці 1.

Табл. 1 – Історія змін
№	Дата	Версія звіту	Опис змін та виправлень
1	15.04.2025	0.1	

2 ЗАВДАННЯ

У межах практичної роботи з дисципліни «Архітектура програмного забезпечення» було детально досліджено патерн проєктування Abstract Factory та його потенційне застосування в архітектурі складних систем, таких як браузер Google Chrome. Робота передбачала вивчення структури патерну, його принципів і особливостей реалізації.
Особливу увагу приділено сценаріям використання, як-от створення сімейств UI-компонентів для різних платформ (наприклад, Windows, macOS, Linux), що є актуальним для кросплатформних додатків, таких як Google Chrome, де патерн застосовується для забезпечення узгодженості інтерфейсу.

3 ОПИС ВИКОНАНОЇ РОБОТИ

У рамках практичної роботи було досліджено архітектуру програмної системи Google Chrome — провідного веб-браузера з багатомільйонною аудиторією. Дослідження охоплювало еволюцію архітектури, її технічні особливості та підходи до забезпечення продуктивності, безпеки й масштабованості.
Google Chrome, випущений у 2008 році, спочатку базувався на проєкті з відкритим кодом Chromium. Зараз він утримує близько 65% світового ринку браузерів. Спершу Chrome використовував рендеринговий двигун WebKit, але в 2013 році перейшов на власний двигун Blink, що дозволило оптимізувати продуктивність і адаптувати архітектуру до сучасних вебтехнологій.
Архітектура Chrome побудована на мультипроцесній моделі, яка включає один головний процес (browser process) для управління інтерфейсом і взаємодії з операційною системою, а також окремі процеси рендерингу (renderer processes) для кожної вкладки чи сайту. Ця ізоляція підвищує стабільність (збій однієї вкладки не впливає на інші) і безпеку завдяки механізму sandboxing, який обмежує доступ рендерингових процесів до системи.
Дослідження також охопило типові сценарії використання патерну в кросплатформних додатках, подібних до Google Chrome, де потрібно забезпечити сумісність компонентів і підтримку різних конфігурацій. Було розглянуто технічні виклики, зокрема складність додавання нових типів об’єктів, і способи їх подолання через чітке планування архітектури.

3	ВИСНОВКИ

У результаті виконання практичної роботи було засвоєно принципи роботи патерну Abstract Factory та його значення для побудови масштабованих і кросплатформних програмних систем. На прикладі архітектури Google Chrome продемонстровано, як цей патерн сприяє ізоляції платформозалежного коду та підтримці узгодженого інтерфейсу користувача. 
Аналіз архітектури браузера дозволив глибше зрозуміти важливість мультипроцесного підходу, розподілу обов’язків між компонентами та забезпечення високих вимог до безпеки і продуктивності.



















ДОДАТОК А

Відеозапис доповіді на YouTube: https://youtu.be/MAAuzdV60WY

0:00 - Початок 
0:08 – Вступ 
0:27 – Загальна структура Сhrome 
0:48 – Основні компоненти системи 
1:11 – Взаємодія між компонентами 
1:29 – Безпека в архітектурі 
2:32 – Якість архітектури Chrome 
3:34 – Патерн Abstract Factory в Google Chrome 
3:55 – Де використовується Abstract Factory в Google Chrome 
4:50 – Приклади коду 
5:46 – Висновки 
6:02 – Кінець 
ДОДАТОК Б

 
Рисунок Б. 1 – Титульний слайд

 
Рисунок Б. 2 – Вступ

 
Рисунок Б. 3 – Огляд архітектури

 
Рисунок Б. 4 – Загальна структура Google Chrome

 
Рисунок Б. 5 – Основні компоненти системи

 
Рисунок Б. 6 – Взяємодія між компонентами

 
Рисунок Б. 7 – Безпека у Google Chrome

 
Рисунок Б. 8 – Якість архітектури

 
Рисунок Б. 9 – Патерн Abstract Factory

 
Рисунок Б. 10 – Переваги використання в архітектурі
 
 
Рисунок Б. 11 – Де використовується цей шаблон

 
Рисунок Б. 12 – Приклади коду

 
Рисунок Б. 13 – Висновки

 
Рисунок Б. 12 – Дякую за увагу 

 
ДОДАТОК В

1. #include <iostream>
2. #include <string>
3. class View {
4. public:
5.     virtual void Render() = 0;
6.     virtual ~View() {}
7. };
8. class Button : public View {
9. public:
10.     virtual void Render() override = 0;
11. };
12. class Menu : public View {
13. public:
14.     virtual void Render() override = 0;
15. };
16. class WindowsButton : public Button {
17. public:
18.     void Render() override { std::cout << "Windows button rendered\n"; }
19. };
20. class WindowsMenu : public Menu {
21. public:
22.     void Render() override { std::cout << "Windows menu rendered\n"; }
23. };
24. class MacOSButton : public Button {
25. public:
26.     void Render() override { std::cout << "macOS button rendered\n"; }
27. };
28. class MacOSMenu : public Menu {
29. public:
30.     void Render() override { std::cout << "macOS menu rendered\n"; }
31. };
32. class ViewFactory {
33. public:
34.     virtual Button* CreateButton() = 0;
35.     virtual Menu* CreateMenu() = 0;
36.     virtual ~ViewFactory() {}
37. };
38. class WindowsViewFactory : public ViewFactory {
39. public:
40.     Button* CreateButton() override { return new WindowsButton(); }
41.     Menu* CreateMenu() override { return new WindowsMenu(); }
42. };
43. class MacOSViewFactory : public ViewFactory {
44. public:
45.     Button* CreateButton() override { return new MacOSButton(); }
46.     Menu* CreateMenu() override { return new MacOSMenu(); }
47. };
48. class BrowserUI {
49.     Button* button;
50.     Menu* menu;
51. public:
52.     BrowserUI(ViewFactory* factory) {
53.         button = factory->CreateButton();
54.         menu = factory->CreateMenu();
55.     }
56.     void Render() {
57.         button->Render();
58.         menu->Render();
59.     }
60.     ~BrowserUI() {
61.         delete button;
62.         delete menu;
63.     }
64. };
65. int main() {
66.     ViewFactory* factory = nullptr;
67.     #ifdef _WIN32
68.         factory = new WindowsViewFactory();
69.     #else
70.         factory = new MacOSViewFactory();
71.     #endif
72.     BrowserUI ui(factory);
73.     ui.Render();
74.     delete factory;
75.     return 0;
76. }
