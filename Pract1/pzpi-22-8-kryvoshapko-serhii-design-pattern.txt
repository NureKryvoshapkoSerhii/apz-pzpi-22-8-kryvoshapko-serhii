МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ

Кафедра «Програмної інженерії»



ЗВІТ
З практичної роботи №1
з дисципліни «Архітектура програмного забезпечення»



Виконав:
ст. гр. ПЗПІ-22-8
Кривошапко С. С.	Перевірив:
ст. викладач кафедри ПІ
Сокорчук І.П.
	



Харків 2025
1 ІСТОРІЯ ЗМІН

Розділ призначений для відображення історії внесення змін, що наведено на таблиці 1.

Табл. 1 – Історія змін
№	Дата	Версія звіту	Опис змін та виправлень
1	13.04.2025	0.1	

2 ЗАВДАННЯ

У межах практичної роботи №1 з дисципліни «Архітектура програмного забезпечення» було поставлено завдання дослідити патерн проєктування Abstract Factory. Це передбачало ознайомлення з його структурою, ключовими принципами та практичними аспектами реалізації.
На початковому етапі увагу було зосереджено на теоретичному вивченні патерну, а також на його класифікації серед інших патернів проєктування. Варто зазначити, що Abstract Factory належить до групи порожнюючих (creational) патернів.
Окремо проаналізовано типові сценарії використання цього патерну, його переваги, а також потенційні обмеження при застосуванні в розробці програмного забезпечення.
Загалом, виконання роботи сприяло глибшому розумінню концепції Abstract Factory, розвитку навичок аналізу архітектурних рішень, а також вдосконаленню вмінь презентації технічної інформації як у письмовій, так і в усній формі.

3 ОПИС ВИКОНАНОЇ РОБОТИ

У процесі виконання роботи було всебічно проаналізовано патерн Abstract Factory. Цей патерн належить до групи порожнюючих (creational) патернів проєктування і забезпечує ефективний механізм створення цілих родин взаємопов’язаних об’єктів без необхідності конкретизувати їхні класи.
Вивчення патерну дало змогу зрозуміти, як реалізувати гнучку та розширювану архітектуру, у якій логіка створення об'єктів винесена в окремі фабрики. Це дозволяє змінювати конкретні реалізації або розширювати функціональність без зміни основного коду клієнта, що сприяє дотриманню принципів SOLID та спрощує підтримку і масштабування програмного забезпечення.

3.1 Сутність патерну «Abstract Factory»:

Патерн Abstract Factory полягає у створенні інтерфейсу (або абстрактного класу), який визначає набір методів для створення взаємопов’язаних об’єктів без прив’язки до конкретних класів. Замість того щоб створювати об’єкти напряму, клієнтський код використовує фабрику, яка інкапсулює логіку їх побудови. Це дозволяє забезпечити узгодженість створюваних об'єктів та легко змінювати їхню реалізацію, не змінюючи код клієнта.

3.2 Структура патерну:

Патерн Abstract Factory має чітко визначену структуру, яка включає кілька основних компонентів:
1.	AbstractFactory (Абстрактна фабрика)
Визначає інтерфейс для створення абстрактних продуктів. Містить методи для створення кожного типу продукту, наприклад: createProductA(), createProductB().
2.	ConcreteFactory (Конкретна фабрика)
Реалізує інтерфейс AbstractFactory та створює конкретні об'єкти продуктів певної родини. Наприклад, ConcreteFactory1 створює ProductA1, ProductB1.
3.	AbstractProduct (Абстрактний продукт)
Визначає інтерфейс продукту, який створюється фабрикою. Наприклад: ProductA, ProductB.
4.	ConcreteProduct (Конкретний продукт)
Конкретна реалізація абстрактного продукту. Кожна конкретна фабрика створює власну реалізацію кожного типу продукту. Наприклад: ProductA1, ProductB1.
5.	Client (Клієнтський код)
Використовує лише інтерфейс AbstractFactory та абстрактних продуктів. Завдяки цьому клієнтський код не залежить від конкретних реалізацій об’єктів, що дозволяє легко змінювати варіанти реалізації, підключаючи інші фабрики.

3.3 Принцип роботи патерну:

Принцип роботи патерну Abstract Factory полягає в організації створення взаємопов’язаних об’єктів певної родини без необхідності вказувати їхні конкретні класи. Замість прямої інстанціації об’єктів, клієнт звертається до абстрактної фабрики, яка інкапсулює логіку створення та надає єдиний інтерфейс для формування пов’язаних продуктів.

3.4	 Застосовність:

Патерн Abstract Factory доцільно використовувати, коли:
1.	Потрібно створювати об’єкти, що належать до однієї родини та мають бути узгодженими між собою.
2.	Система має бути незалежною від конкретних класів створюваних об’єктів.
3.	Потрібна можливість легко змінювати варіанти реалізації продуктів (наприклад, UI для різних платформ).
4.	Планується розширення системи новими наборами продуктів без змін у клієнтському коді.
3.5	Переваги та недоліки:

Переваги:
-	Клієнт не залежить від конкретних класів об’єктів, тож їх легко замінити.
-	Щоб змінити набір об’єктів (наприклад, стиль інтерфейсу), досить змінити одну фабрику.
-	Усі об’єкти з однієї фабрики завжди підходять одне одному, тож немає плутанини.
Недоліки:
-	Якщо треба додати новий об’єкт (наприклад, новий елемент інтерфейсу), доводиться змінювати багато коду — і абстрактну фабрику, і всі конкретні фабрики.
-	Якщо набори об’єктів дуже прості чи їх мало, цей шаблон може бути занадто складним і непотрібним.

3.6	 Реальні приклади використання:

Патерн Abstract Factory широко застосовується в розробці програмного забезпечення, особливо там, де потрібна підтримка різних варіантів реалізації без зміни клієнтського коду. Ось кілька практичних прикладів:
1.	Графічні інтерфейси (GUI)
2.	Тематичне оформлення (Skins/Themes)
3.	Ігрова розробка
4.	Системи баз даних

3.7	 Реалізація патерну на С#:

У цьому прикладі реалізована система графічного інтерфейсу на C#, яка демонструє застосування патерну Abstract Factory для створення наборів компонентів (кнопок і меню) у двох стилях — Windows і macOS. Код дозволяє клієнту створювати цілі сімейства пов’язаних об’єктів, не прив’язуючись до їхніх конкретних класів, що забезпечує гнучкість і модульність.

4	ВИСНОВКИ

У результаті виконаної роботи було детально досліджено патерн проєктування Abstract Factory та його застосування в контексті створення систем графічного інтерфейсу з використанням C#. Патерн Abstract Factory дозволяє ефективно організовувати створення сімейств пов’язаних об’єктів, забезпечуючи ізоляцію клієнтського коду від конкретних реалізацій. Реалізація цього патерну продемонструвала його переваги, зокрема гнучкість у перемиканні між різними наборами компонентів (наприклад, стилями Windows і macOS), модульність системи та спрощення підтримки коду в складних проєктах із кількома варіантами конфігурацій.





ДОДАТОК А

Відеозапис доповіді на YouTube: https://youtu.be/1iOC2Rv3F9o
0:00 - Вступ 
0:11 – Вступ до патернів проектування
0:37 – Що таке шаблон Abstract Factory 
1:10 – Як працює Abstract Factory 
2:05 – Приклад використання шаблону 
2:52 – Переваги та недоліки Abstract Factory 
3:40 - Abstract Factory vs інші шаблони
4:12 – Приклади використання патерну на С#
5:04 – Висновки 
5:50 – Список використаних джерел 
 
ДОДАТОК Б

 
Рисунок Б. 1 – Титульний слайд

 
Рисунок Б. 2 – Вступ

 
Рисунок Б. 3 – Про шаблон проектування Abstract Factory

 
Рисунок Б. 4 – Як працює Abstract Factory

 
Рисунок Б. 5 – Приклад використання шаблону

 
Рисунок Б. 6 – Переваги та недоліки

 
Рисунок Б. 7 – Abstract Factory проти інших шаблонів

 
Рисунок Б. 8 – Приклад використання патерну в коді

 
Рисунок Б. 9 – Висновки

 
Рисунок Б. 10 – Список використаних джерел
 
 
Рисунок Б. 11 – Слайд «Дякую за увагу!»

 
ДОДАТОК В

1. // Абстрактні продукти (загальні інтерфейси для об’єктів)
2. public interface IButton { void Render(); }
3. public interface IMenu { void Display(); }
4. 
5. // Конкретні продукти для Windows (реалізації для одного стилю)
6. public class WindowsButton : IButton
7. {
8.     public void Render() => Console.WriteLine("Рендер кнопки у стилі Windows");
9. }
10. public class WindowsMenu : IMenu
11. {
12.     public void Display() => Console.WriteLine("Відображення меню у стилі Windows");
13. }
14. 
15. // Конкретні продукти для macOS (реалізації для іншого стилю)
16. public class MacOSButton : IButton
17. {
18.     public void Render() => Console.WriteLine("Рендер кнопки у стилі macOS");
19. }
20. public class MacOSMenu : IMenu
21. {
22.     public void Display() => Console.WriteLine("Відображення меню у стилі macOS");
23. }
24. 
25. // Абстрактна фабрика (інтерфейс для створення набору об’єктів)
26. public interface IGUIFactory
27. {
28.     IButton CreateButton();
29.     IMenu CreateMenu();
30. }
31. 
32. // Конкретні фабрики (створюють набори об’єктів одного стилю)
33. public class WindowsFactory : IGUIFactory
34. {
35.     public IButton CreateButton() => new WindowsButton();
36.     public IMenu CreateMenu() => new WindowsMenu();
37. }
38. public class MacOSFactory : IGUIFactory
39. {
40.     public IButton CreateButton() => new MacOSButton();
41.     public IMenu CreateMenu() => new MacOSMenu();
42. }
43. 
44. // Клієнт (використовує фабрику, не знаючи деталей реалізації)
45. public class Client
46. {
47.     private readonly IButton _button;
48.     private readonly IMenu _menu;
49.     public Client(IGUIFactory factory)
50.     {
51.         _button = factory.CreateButton();
52.         _menu = factory.CreateMenu();
53.     }
54.     public void RenderUI()
55.     {
56.         _button.Render();
57.         _menu.Display();
58.     }
59. }
60. 
61. // Використання (перемикання стилів змінює фабрику)
62. class Program
63. {
64.     static void Main()
65.     {
66.         IGUIFactory factory = new WindowsFactory(); // або new MacOSFactory()
67.         Client client = new Client(factory);
68.         client.RenderUI();
69.     }
70. }
